# 面试题 - 综合题

> 综合类、开放性问题、场景题

---

## 1. 开放性问题

### Q1: 你未来3年的职业规划是什么？

**参考回答**：

**技术方向**：
- 深入学习分布式系统架构
- 掌握微服务设计模式
- 学习Go、Kubernetes等新技术
- 提升系统设计能力

**能力提升**：
- 主导核心项目开发
- 提升技术决策能力
- 培养团队协作能力
- 积累最佳实践

**目标**：
- 1年内：成为团队技术骨干
- 2年内：掌握分布式架构设计
- 3年内：具备架构师能力

---

### Q2: 你为什么选择Java？

**参考回答**：

1. **生态丰富**
   - Spring生态系统完善
   - 大量开源框架
   - 社区活跃

2. **跨平台**
   - 一次编写，到处运行
   - 适合企业级应用

3. **就业机会多**
   - 市场需求大
   - 企业级应用首选
   - 薪资水平较高

4. **个人原因**
   - 大学学习的是Java
   - 感兴趣且擅长
   - 有实战经验

---

### Q3: 你平时是如何学习新技术的？

**参考回答**：

1. **学习渠道**
   - 官方文档和API
   - 技术博客和公众号
   - 开源项目源码
   - 技术书籍

2. **学习方法**
   - 理论学习：阅读文档、书籍
   - 实践验证：写Demo、测试
   - 项目应用：在实际项目中使用
   - 总结输出：写文章、做分享

3. **持续学习**
   - 关注技术趋势
   - 保持好奇心
   - 制定学习计划
   - 坚持每周学习

**实际案例**：
学习Pgvector时，我先阅读了PostgreSQL官方文档，然后写了一个向量检索的Demo，最后在文档处理项目中应用。

---

### Q4: 你遇到过什么技术难题？是如何解决的？

**参考回答**：

**难题**：万物云对接中，多个系统接口不兼容，数据格式不统一

**解决过程**：
1. 深入分析各系统接口文档
2. 设计统一的数据对接标准
3. 开发适配器转换数据格式
4. 实现本地消息表保证一致性
5. 开发监控及时发现问题

**结果**：成功对接3个系统，数据一致性99%

**收获**：
- 掌握了系统对接方法
- 理解了适配器模式应用
- 学会了保证最终一致性

---

## 2. 场景题

### Q5: 设计一个秒杀系统

**参考思路**：

1. **前端优化**
   - 静态化页面
   - CDN加速
   - 限流防刷

2. **后端设计**
   - Redis预减库存
   - 消息队列异步下单
   - 分布式锁防止超卖

3. **数据库优化**
   - 分库分表
   - 索引优化
   - 读写分离

4. **降级限流**
   - 令牌桶限流
   - 服务降级
   - 熔断保护

---

### Q6: 设计一个限流系统

**参考思路**：

1. **限流算法**
   - 令牌桶算法
   - 漏桶算法
   - 滑动窗口
   - 固定窗口

2. **Redis实现**
   - 计数器+过期时间
   - 滑动窗口Redis
   - Lua脚本保证原子性

3. **应用场景**
   - 接口限流
   - IP限流
   - 用户限流

---

### Q7: 设计一个短链接系统

**参考思路**：

1. **短链接生成**
   - 自增ID
   - 雪花算法
   - 随机字符串

2. **存储方案**
   - Redis缓存热点
   - MySQL持久化
   - 一致性保证

3. **性能优化**
   - 布隆过滤器防重复
   - 缓存短链接
   - 分库分表

---

### Q8: 如何保证接口幂等性？

**参考思路**：

1. **唯一标识**
   - 请求携带唯一ID
   - Redis存储已处理ID
   - 过期时间控制

2. **乐观锁**
   - 版本号控制
   - CAS更新

3. **数据库约束**
   - 业务ID唯一
   - 唯一索引

4. **分布式锁**
   - Redis分布式锁
   - 防止重复提交

---

### Q9: 如何实现分布式事务？

**参考思路**：

1. **2PC/XA**
   - 强一致性
   - 性能较差

2. **TCC**
   - Try、Confirm、Cancel
   - 需要实现补偿逻辑

3. **Saga**
   - 长事务拆分
   - 补偿事务

4. **本地消息表（推荐）**
   - 实现简单
   - 可靠性高
   - 最终一致性

---

### Q10: 如何设计RPC框架？

**参考思路**：

1. **核心组件**
   - 服务注册发现
   - 动态代理
   - 序列化
   - 网络传输

2. **调用流程**
   - 服务消费者调用本地代理
   - 动态代理生成请求
   - 序列化发送到服务提供者
   - 服务提供者处理后返回

3. **负载均衡**
   - 随机
   - 轮询
   - 一致性Hash

---

## 3. 脑力题

### Q11: 找出数组中只出现一次的数字

```java
public int singleNumber(int[] nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
}
```

---

### Q12: 手写一个简单的LRU缓存

```java
public class LRUCache<K, V> {
    private int capacity;
    private LinkedHashMap<K, V> cache;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new LinkedHashMap<>(16, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                return size() > capacity;
            }
        };
    }
    
    public V get(K key) {
        return cache.get(key);
    }
    
    public void put(K key, V value) {
        cache.put(key, value);
    }
}
```

---

### Q13: 手写一个简单的线程池

```java
public class SimpleThreadPool {
    private List<WorkerThread> workers;
    private BlockingQueue<Runnable> taskQueue;
    private volatile boolean running;
    
    public SimpleThreadPool(int poolSize) {
        this.taskQueue = new LinkedBlockingQueue<>();
        this.workers = new ArrayList<>();
        this.running = true;
        
        for (int i = 0; i < poolSize; i++) {
            WorkerThread worker = new WorkerThread();
            workers.add(worker);
            worker.start();
        }
    }
    
    public void execute(Runnable task) {
        if (running) {
            taskQueue.offer(task);
        }
    }
    
    public void shutdown() {
        running = false;
        for (WorkerThread worker : workers) {
            worker.interrupt();
        }
    }
    
    class WorkerThread extends Thread {
        @Override
        public void run() {
            while (running || !taskQueue.isEmpty()) {
                try {
                    Runnable task = taskQueue.take();
                    task.run();
                } catch (InterruptedException e) {
                    break;
                }
            }
        }
    }
}
```

---

### Q14: 实现一个简单的单例模式

```java
// 饿汉式
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        return INSTANCE;
    }
}

// 懒汉式（线程安全）
public class Singleton {
    private static volatile Singleton INSTANCE;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}

// 静态内部类
public class Singleton {
    private Singleton() {}
    
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

---

### Q15: 实现一个简单的生产者-消费者模型

```java
public class ProducerConsumer {
    private BlockingQueue<Integer> queue = new LinkedBlockingQueue<>(10);
    private volatile boolean running = true;
    
    public void start() {
        for (int i = 0; i < 3; i++) {
            new Thread(new Producer()).start();
            new Thread(new Consumer()).start();
        }
    }
    
    public class Producer implements Runnable {
        @Override
        public void run() {
            int value = 0;
            while (running) {
                try {
                    queue.put(value);
                    System.out.println("生产: " + value);
                    value++;
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    break;
                }
            }
        }
    }
    
    public class Consumer implements Runnable {
        @Override
        public void run() {
            while (running) {
                try {
                    Integer value = queue.take();
                    System.out.println("消费: " + value);
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    break;
                }
            }
        }
    }
}
```

---

## 🔥 补充问题

1. 设计一个抽奖系统
2. 设计一个排行榜系统
3. 设计一个消息推送系统
4. 实现一个简单的HashMap
5. 实现一个简单的IOC容器

---

**建议多练习算法题，结合项目经验回答开放性问题。**